/// Egg System — MohnSter egg creation, incubation, and hatching
/// Eggs can hatch from card scans, ESP32 hibernation, or ecosystem activity
library;

import 'dart:math';
import '../models/mohnster.dart';

/// Types of eggs that can be obtained
enum EggType {
  /// Standard egg from scanning a card
  cardScan,

  /// Earned from cross-platform ecosystem activity
  ecosystem,

  /// Created when two MohnSters fuse DNA at max level
  dnaFusion,

  /// Rare egg from daily login streaks (30+ days)
  streak,

  /// Legendary egg from tournament wins
  tournament,

  /// ESP32 node-generated egg (passive online presence)
  nodeGenerated,

  /// Mystery egg from random world events
  mystery,
}

/// Egg rarity probabilities based on source
class EggHatchTable {
  static const Map<EggType, Map<Rarity, double>> hatchProbabilities = {
    EggType.cardScan: {
      Rarity.common: 0.50,
      Rarity.uncommon: 0.25,
      Rarity.rare: 0.15,
      Rarity.epic: 0.07,
      Rarity.legendary: 0.025,
      Rarity.mythic: 0.005,
    },
    EggType.ecosystem: {
      Rarity.common: 0.30,
      Rarity.uncommon: 0.30,
      Rarity.rare: 0.20,
      Rarity.epic: 0.12,
      Rarity.legendary: 0.06,
      Rarity.mythic: 0.02,
    },
    EggType.dnaFusion: {
      Rarity.common: 0.0,
      Rarity.uncommon: 0.10,
      Rarity.rare: 0.30,
      Rarity.epic: 0.30,
      Rarity.legendary: 0.20,
      Rarity.mythic: 0.10,
    },
    EggType.streak: {
      Rarity.common: 0.20,
      Rarity.uncommon: 0.30,
      Rarity.rare: 0.25,
      Rarity.epic: 0.15,
      Rarity.legendary: 0.08,
      Rarity.mythic: 0.02,
    },
    EggType.tournament: {
      Rarity.common: 0.0,
      Rarity.uncommon: 0.0,
      Rarity.rare: 0.20,
      Rarity.epic: 0.35,
      Rarity.legendary: 0.30,
      Rarity.mythic: 0.15,
    },
    EggType.nodeGenerated: {
      Rarity.common: 0.40,
      Rarity.uncommon: 0.30,
      Rarity.rare: 0.15,
      Rarity.epic: 0.10,
      Rarity.legendary: 0.04,
      Rarity.mythic: 0.01,
    },
    EggType.mystery: {
      Rarity.common: 0.25,
      Rarity.uncommon: 0.25,
      Rarity.rare: 0.20,
      Rarity.epic: 0.15,
      Rarity.legendary: 0.10,
      Rarity.mythic: 0.05,
    },
  };

  /// Steps required to hatch each egg type
  static const Map<EggType, int> hatchStepsRequired = {
    EggType.cardScan: 50, // 50 actions/steps
    EggType.ecosystem: 100, // more activity needed
    EggType.dnaFusion: 200, // longest incubation
    EggType.streak: 30, // login streaks count as steps
    EggType.tournament: 10, // quick hatch reward
    EggType.nodeGenerated: 144, // 24 hours at 1 step per 10 min heartbeat
    EggType.mystery: 75,
  };
}

/// MohnSter egg waiting to hatch
class MohnsterEgg {
  final String id;
  final String ownerId;
  final EggType type;
  final Element? hintElement; // may hint at what's inside
  final int currentSteps;
  final int requiredSteps;
  final DateTime createdAt;
  final String? sourceCardFingerprint; // if from card scan
  final String? sourceNodeId; // if generated by ESP32 node
  final String? fusionParent1Id; // if from DNA fusion
  final String? fusionParent2Id;

  const MohnsterEgg({
    required this.id,
    required this.ownerId,
    required this.type,
    this.hintElement,
    this.currentSteps = 0,
    required this.requiredSteps,
    required this.createdAt,
    this.sourceCardFingerprint,
    this.sourceNodeId,
    this.fusionParent1Id,
    this.fusionParent2Id,
  });

  double get hatchProgress =>
      (currentSteps / requiredSteps).clamp(0.0, 1.0);
  bool get isReadyToHatch => currentSteps >= requiredSteps;
  int get stepsRemaining => (requiredSteps - currentSteps).clamp(0, requiredSteps);

  MohnsterEgg addSteps(int steps) => MohnsterEgg(
        id: id,
        ownerId: ownerId,
        type: type,
        hintElement: hintElement,
        currentSteps: currentSteps + steps,
        requiredSteps: requiredSteps,
        createdAt: createdAt,
        sourceCardFingerprint: sourceCardFingerprint,
        sourceNodeId: sourceNodeId,
        fusionParent1Id: fusionParent1Id,
        fusionParent2Id: fusionParent2Id,
      );

  Map<String, dynamic> toJson() => {
        'id': id,
        'ownerId': ownerId,
        'type': type.name,
        'hintElement': hintElement?.name,
        'currentSteps': currentSteps,
        'requiredSteps': requiredSteps,
        'createdAt': createdAt.toIso8601String(),
        'sourceCardFingerprint': sourceCardFingerprint,
        'sourceNodeId': sourceNodeId,
        'fusionParent1Id': fusionParent1Id,
        'fusionParent2Id': fusionParent2Id,
      };

  factory MohnsterEgg.fromJson(Map<String, dynamic> json) => MohnsterEgg(
        id: json['id'] as String,
        ownerId: json['ownerId'] as String,
        type: EggType.values.byName(json['type'] as String),
        hintElement: json['hintElement'] != null
            ? Element.values.byName(json['hintElement'] as String)
            : null,
        currentSteps: json['currentSteps'] as int? ?? 0,
        requiredSteps: json['requiredSteps'] as int,
        createdAt: DateTime.parse(json['createdAt'] as String),
        sourceCardFingerprint: json['sourceCardFingerprint'] as String?,
        sourceNodeId: json['sourceNodeId'] as String?,
        fusionParent1Id: json['fusionParent1Id'] as String?,
        fusionParent2Id: json['fusionParent2Id'] as String?,
      );
}

/// Egg creation and hatching service
class EggService {
  final Random _rng;

  EggService({int? seed}) : _rng = Random(seed);

  /// Create a new egg from a card scan
  MohnsterEgg createFromCardScan({
    required String ownerId,
    required String cardFingerprint,
    Element? detectedElement,
  }) {
    return MohnsterEgg(
      id: _generateId(),
      ownerId: ownerId,
      type: EggType.cardScan,
      hintElement: detectedElement,
      requiredSteps:
          EggHatchTable.hatchStepsRequired[EggType.cardScan]!,
      createdAt: DateTime.now(),
      sourceCardFingerprint: cardFingerprint,
    );
  }

  /// Create a node-generated egg (ESP32 creates one periodically)
  MohnsterEgg createFromNode({
    required String ownerId,
    required String nodeId,
  }) {
    return MohnsterEgg(
      id: _generateId(),
      ownerId: ownerId,
      type: EggType.nodeGenerated,
      hintElement: Element.values[_rng.nextInt(Element.values.length)],
      requiredSteps:
          EggHatchTable.hatchStepsRequired[EggType.nodeGenerated]!,
      createdAt: DateTime.now(),
      sourceNodeId: nodeId,
    );
  }

  /// Create a DNA fusion egg from two max-level MohnSters
  MohnsterEgg createFromFusion({
    required String ownerId,
    required Mohnster parent1,
    required Mohnster parent2,
  }) {
    assert(parent1.level >= 50 && parent2.level >= 50,
        'Both parents must be max level (50) for DNA fusion');

    // Hybrid element — pick the rarer parent's element
    final hintElement = parent1.rarity.index >= parent2.rarity.index
        ? parent1.element
        : parent2.element;

    return MohnsterEgg(
      id: _generateId(),
      ownerId: ownerId,
      type: EggType.dnaFusion,
      hintElement: hintElement,
      requiredSteps:
          EggHatchTable.hatchStepsRequired[EggType.dnaFusion]!,
      createdAt: DateTime.now(),
      fusionParent1Id: parent1.id,
      fusionParent2Id: parent2.id,
    );
  }

  /// Create an ecosystem reward egg
  MohnsterEgg createEcosystemEgg({
    required String ownerId,
    required String platform, // e.g. 'MohnMenu', 'NeighborTechs'
  }) {
    return MohnsterEgg(
      id: _generateId(),
      ownerId: ownerId,
      type: EggType.ecosystem,
      hintElement: _platformToElement(platform),
      requiredSteps:
          EggHatchTable.hatchStepsRequired[EggType.ecosystem]!,
      createdAt: DateTime.now(),
    );
  }

  /// Create a streak reward egg
  MohnsterEgg createStreakEgg({required String ownerId, int streakDays = 30}) {
    return MohnsterEgg(
      id: _generateId(),
      ownerId: ownerId,
      type: EggType.streak,
      requiredSteps:
          EggHatchTable.hatchStepsRequired[EggType.streak]!,
      createdAt: DateTime.now(),
    );
  }

  /// Hatch an egg — returns the new MohnSter
  Mohnster hatchEgg(MohnsterEgg egg) {
    assert(egg.isReadyToHatch, 'Egg is not ready to hatch');

    final rarity = _rollRarity(egg.type);
    final element =
        egg.hintElement ?? Element.values[_rng.nextInt(Element.values.length)];
    final stats = MohnsterStats.forRarity(rarity, seed: egg.id.hashCode);
    final name = _generateName(element, rarity);

    return Mohnster(
      id: 'mohnster_${egg.id}',
      name: name,
      sourceCardFingerprint: egg.sourceCardFingerprint,
      ownerId: egg.ownerId,
      element: element,
      rarity: rarity,
      state: MohnsterState.active,
      baseStats: stats,
      createdAt: DateTime.now(),
      eggCreatedAt: egg.createdAt,
      eggHatchProgress: 100,
      eggType: egg.type.name,
    );
  }

  Rarity _rollRarity(EggType eggType) {
    final probs = EggHatchTable.hatchProbabilities[eggType]!;
    final roll = _rng.nextDouble();
    double cumulative = 0;
    for (final entry in probs.entries) {
      cumulative += entry.value;
      if (roll <= cumulative) return entry.key;
    }
    return Rarity.common;
  }

  Element? _platformToElement(String platform) {
    const mapping = {
      'MohnMenu': Element.flame,
      'NeighborTechs': Element.thunder,
      'MohnServe': Element.crystal,
      'MohnMatrix': Element.shadow,
      'FlamingSocial': Element.flame,
      'MohnMove': Element.nature,
      'MohnPay': Element.aqua,
    };
    return mapping[platform];
  }

  String _generateName(Element element, Rarity rarity) {
    const prefixes = {
      Element.flame: ['Pyre', 'Ember', 'Blaze', 'Scorch', 'Inferna'],
      Element.aqua: ['Tide', 'Surge', 'Frost', 'Ripple', 'Depths'],
      Element.nature: ['Thorn', 'Bloom', 'Root', 'Verdant', 'Spore'],
      Element.thunder: ['Volt', 'Spark', 'Storm', 'Zapper', 'Arc'],
      Element.shadow: ['Shade', 'Dusk', 'Void', 'Phantom', 'Eclipse'],
      Element.crystal: ['Prism', 'Shard', 'Gleam', 'Facet', 'Lumen'],
    };
    const suffixes = {
      Rarity.common: ['ling', 'bit', 'pup'],
      Rarity.uncommon: ['claw', 'fang', 'wing'],
      Rarity.rare: ['strike', 'fury', 'guard'],
      Rarity.epic: ['lord', 'bane', 'wraith'],
      Rarity.legendary: ['sovereign', 'apex', 'titan'],
      Rarity.mythic: ['primordial', 'eternal', 'genesis'],
    };

    final prefix =
        prefixes[element]![_rng.nextInt(prefixes[element]!.length)];
    final suffix =
        suffixes[rarity]![_rng.nextInt(suffixes[rarity]!.length)];
    return '$prefix$suffix';
  }

  String _generateId() {
    const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
    return List.generate(20, (_) => chars[_rng.nextInt(chars.length)]).join();
  }
}
